<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Nomad - cmb</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link rel="stylesheet" href="../../css/lightbox.min.css" />
  <link href="../../css/extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Nomad";
    var mkdocs_page_input_path = "media/nomad.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="../../js/lightbox.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> cmb</a>
        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../contact/">Contact</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Car stuff</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/14cux/">14CUX</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/14cux_rescue/">14CUX rescue kit</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/europa_jps/">Lotus Europa JPS</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/blue_star/">Mini Blue Star</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/mems_interface/">Rover MEMS diagnostics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/r380_oil_pump/">Rover R380 oil pump</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/steering_wheel_adapters/">Steering wheel adapters</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../car_stuff/sykes_acr/">Sykes-Pickavant ACR</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Media</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../connections/">Connections</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cosmos/">Cosmos</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ferrari_vhs/">Ferrari promotional VHS</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Nomad</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#nomad-resource-explorer">Nomad Resource Explorer</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#notes-to-other-developers-and-hackers">Notes to other developers and hackers</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#disassembly-methodology">Disassembly methodology</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#resource-explorer-source-code">Resource Explorer source code</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#modifying-the-original-game">Modifying the original game</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#related-resources">Related resources</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#game-version">Game version</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#disney-association">Disney association</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dat-archive-format">DAT archive format</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lz-compression-algorithm">LZ compression algorithm</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mission-and-conversation-text">Mission and conversation text</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#palettes">Palettes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#static-image-data">Static image data</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inventory-objects-and-overlay-images-stp">Inventory objects and overlay images (.STP)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#planet-surface-textures-pln">Planet surface textures (.PLN)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#alien-animations">Alien animations</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#del-files">DEL files</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#delta-table">Delta table</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#anm-files">ANM files</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#header">Header</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#data">Data</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sqb-files">SQB files</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#header_1">Header</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sound">Sound</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#decoding-dpcm-audio">Decoding DPCM audio</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-tables">Data tables</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#enumerations-and-indexing">Enumerations and indexing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#alientab">ALIEN.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cclasstab-communication-jammer-table">CCLASS.TAB - Communication Jammer Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#eclasstab-engine-class-table">ECLASS.TAB - Engine Class Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#facttab">FACT.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#inventtab">INVENT.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lboostertab-labor-botbooster-data">LBOOSTER.TAB - Labor Botbooster Data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lclasstab-labor-bot-class-data">LCLASS.TAB - Labor Bot Class Data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#mclasstab-missile-class-table">MCLASS.TAB - Missile Class Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#metatab">META.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#metatxttab">METATXT.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#missiontab-mission-table">MISSION.TAB - Mission Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#mistextidx-mission-text-index">MISTEXT.IDX - Mission Text Index</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#mistextidx-mission-text">MISTEXT.IDX - Mission Text</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#msystab-missile-system-table">MSYS.TAB - Missile System Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#objecttab-inventory-object-table">OBJECT.TAB - Inventory Object Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pclasstab-place-class-data">PCLASS.TAB - Place Class Data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#placetab">PLACE.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#podclasstab-unused">PODCLASS.TAB - Unused</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rclasstab-robot-class-table">RCLASS.TAB - Robot Class Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scclasstab-scanner-class-table">SCCLASS.TAB - Scanner Class Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sclasstab-ship-class-table">SCLASS.TAB - Ship Class Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#shclasstab-shield-class-table">SHCLASS.TAB - Shield Class Table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#shiptab-ship-data">SHIP.TAB - Ship Data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stclasstab-star-class-table">STCLASS.TAB - Star Class Table</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#talk-files">Talk files</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#tlkxcxxxtxtidx-and-tlkxrxxxtxtidx">TLKXCxxx.TXT/.IDX and TLKXRxxx.TXT/.IDX</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tlkncxxxtab-and-tlknrxxxtab">TLKNCxxx.TAB and TLKNRxxx.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tlkprxxxtab">TLKPRxxx.TAB</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tlktcxxxtab-and-tlktrxxxtab">TLKTCxxx.TAB and TLKTRxxx.TAB</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#smfontbin-and-lgfontbin">SMFONT.BIN and LGFONT.BIN</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sav-file-format">SAV file format</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#alien-state-heap-astate_heap">Alien State Heap (astate_heap)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#encounterrelationship-tables-encount_relate-and-encount_relate2">Encounter/Relationship Tables (encount_relate and encount_relate2)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#labor-robot-heap-labor_heap">Labor Robot Heap (labor_heap)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#setup-table-setup_tab">Setup Table (setup_tab)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#demo-file">Demo file</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../quarantine/">Quarantine (Gametek)</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Tools</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../tools/snap-on_kra300b/">Snap-on KRA-300B</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../tools/tire_inflators/">Tire inflators</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">cmb</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Media &raquo;</li>
        
      
    
    <li>Nomad</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="nomad-reverse-engineering">Nomad reverse engineering</h1>
<p>Published: 2020-03-24</p>
<p><em>Nomad</em> is an obscure space-exploration PC game, developed by Papyrus Design Group and Intense! Interactive, and published by GameTek in 1993. My copy was given to me by a classmate who had found it in a discount bin for $4 not long after its release (thanks Pete!) I've been curious about the nature of the game engine and its data files for a long time, so I recently spent some time reverse engineering a good portion of it. The main tools I used for this effort were the debugger in <a href="https://www.dosbox.com/">DOSBox</a> and IDA Freeware Version 5.0 (a copy of which is <a href="https://www.scummvm.org/news/20180331/">hosted by the ScummVM project</a>).</p>
<p>I credit my dad (Dan) with introducing me to this type of hacking in the early '90s, and for encouraging the technical curiosity that I have had ever since.</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<h2 id="nomad-resource-explorer">Nomad Resource Explorer</h2>
<p>I've created a graphical tool that you can use to browse/view the game resources. The code is available <a href="https://github.com/colinbourassa/nomad-resource-explorer">from my GitHub repo</a>, and you can also <a href="https://github.com/colinbourassa/nomad-resource-explorer/releases/latest">download executables for Linux and Windows</a>. This utility is licensed GNU GPL v3.</p>
<p>Although the information here could certainly be used to create saved-game editors or game resource editors, that's beyond the scope of this project. I invite others to use this documentation to create their own software. As always, if you have additional information that you could contribute to this page, please <a href="mailto:colin.bourassa@gmail.com">contact me</a>.</p>
<p><a data-lightbox="all_images" data-title="Nomad Resource Explorer - planet" href="../images/nre-screenshot-planet.png"><img alt="Nomad Resource Explorer - planet" class="rowthumb" src="../images/nre-screenshot-planet.png" /></a>
<a data-lightbox="all_images" data-title="Nomad Resource Explorer - alien" href="../images/nre-screenshot-alien.png"><img alt="Nomad Resource Explorer - alien" class="rowthumb" src="../images/nre-screenshot-alien.png" /></a>
<a data-lightbox="all_images" data-title="Nomad Resource Explorer - object" href="../images/nre-screenshot-object.png"><img alt="Nomad Resource Explorer - object" class="rowthumb" src="../images/nre-screenshot-object.png" /></a>
<a data-lightbox="all_images" data-title="Nomad Resource Explorer - fullscreen" href="../images/nre-screenshot-fullscreen.png"><img alt="Nomad Resource Explorer - fullscreen" class="rowthumb" src="../images/nre-screenshot-fullscreen.png" /></a>
<a data-lightbox="all_images" data-title="Nomad Resource Explorer - conversation" href="../images/nre-screenshot-conversation.png"><img alt="Nomad Resource Explorer - conversation" class="rowthumb" src="../images/nre-screenshot-conversation.png" /></a></p>
<h2 id="notes-to-other-developers-and-hackers">Notes to other developers and hackers</h2>
<h3 id="disassembly-methodology">Disassembly methodology</h3>
<p>Disassembly of the main executable was a substantial task given its size and its use of code overlays. Early in the process, I focused on identifying code that loaded data tables from the game's resource files. Labeling the segments/offsets where these tables were stored in memory was very useful in identifying routines that handled that data.</p>
<p><a data-lightbox="all_images" data-title="Nomad disassembly in IDA" href="../images/nomad-ida.png"><img alt="Nomad disassembly in IDA" class="centerthumb" src="../images/nomad-ida.png" /></a></p>
<p>The game's system for defining the layout of dialog boxes uses several different structs that carry information about X,Y positioning and the types of widgets to display. These dialog data structs also contain function pointers to routines that do the drawing for certain regions. There are a large number of fields across several different structure definitions used by the game, and I only scratched the surface of this system; it wasn't really necessary for reversing the game's data file formats, which was my primary goal.</p>
<p>You may have noticed that there's no information in this article about the game's 3D ship models. I personally have no experience with 3D rendering engines, but if anyone out there can shed some light on the details of the game's 3D engine or (especially) the format of the .BIN models (from TEST.DAT), please <a href="mailto:colin.bourassa@gmail.com">get in touch</a>.</p>
<h3 id="resource-explorer-source-code">Resource Explorer source code</h3>
<p>The Nomad Resource Explorer code relies on tightly packed struct definitions (without padding) to match up to the binary file formats. This struct packing is not a feature that is strictly defined by the C/C++ language, but rather is implemented differently depending on the compiler. The code currently uses the <code>__attribute__((packed))</code> directive, which is respected by the GCC family of compilers as well as LLVM/Clang. MinGW also works, although some versions apparently require the GCC parameter <code>-mno-ms-bitfields</code> to force the packing. (This is therefore added as a compiler option in CMakeLists.txt.) If anyone attempts to use a Microsoft compiler, note that some additional work will be required to introduce the <code>#pragma pack(1)</code> directive.</p>
<h3 id="modifying-the-original-game">Modifying the original game</h3>
<p>With the information available here, it would certainly be possible to modify the original game. To simplify matters, you should be able to skip the step of LZ-compressing the files packed into the DAT archives. These archives support storage of uncompressed files as well, with the flags in the index entries set appropriately. This would result in significantly larger DAT archives, but it would also allow changing the game's data files directly within their container and without unpacking/repacking. If you want to simply change a few values with a hex editor, this would be much more convenient.</p>
<h2 id="related-resources">Related resources</h2>
<ul>
<li><a href="https://wiki.multimedia.cx/">MultimediaWiki</a>: documents the technical details on a wide range of audio/video codecs</li>
<li><a href="http://www.shikadi.net/moddingwiki/Main_Page">DOS Game Modding Wiki</a>: centralized collection of information (including file format documentation) obtained through reverse-engineering of classic DOS games, along with editors and tools to modify game resources</li>
<li><a href="https://wiki.osdev.org/">OSDev Wiki</a></li>
<li><a href="https://forum.xentax.com/">XeNTaX Game Research Forum</a></li>
<li><a href="http://vgmpf.com/Wiki/index.php?title=Main_Page">Video Game Music Preservation Foundation</a></li>
<li><a href="http://www.scs.stanford.edu/05au-cs240c/lab/hardware/SoundBlaster.pdf">Sound Blaster Series - Hardware Programming Guide</a></li>
</ul>
<h2 id="game-version">Game version</h2>
<p>All of my work here was done with the following version of this game:</p>
<blockquote>
<p>Nomad v1.01.00<br/>
Compiled: 14:16:48 on February 01 1994</p>
</blockquote>
<p>The files packaged with this release can be identified with the following md5sum fingerprints:</p>
<table>
<thead>
<tr>
<th>Filename</th>
<th>md5sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOMAD.EXE</td>
<td><code>24246d51b851c02260992ec1d10de3bb</code></td>
</tr>
<tr>
<td>ANIM.DAT</td>
<td><code>9502592e48404dca17dda84b2b79caca</code></td>
</tr>
<tr>
<td>CONVERSE.DAT</td>
<td><code>394b8fad1025f0f2526ce71f8ab59cf2</code></td>
</tr>
<tr>
<td>INVENT.DAT</td>
<td><code>bd80c2012775dcfe03a58fc0a444137b</code></td>
</tr>
<tr>
<td>SAMPLES.DAT</td>
<td><code>8d5615377223f2d4d10fdc373aaaba90</code></td>
</tr>
<tr>
<td>TEST.DAT</td>
<td><code>fd0e46e22eb844d685958e3e17005413</code></td>
</tr>
</tbody>
</table>
<p>In the routines used by NOMAD.EXE to manage buffer regions, the marker bytes 52 47 ("RG") and 4F 4B ("OK") are used. These might be the signatures of two programmers that worked on the game -- Richard Garcia and Omar Khudari.</p>
<h2 id="disney-association">Disney association</h2>
<p>Some reviewers of this game have commented on the fact that it contains several references to the Disneyland "Space Mountain" attraction, apparently because of some early licensing agreement with Disney that did not survive to the final release. The in-game log is titled "Space Mountain Log", and the design of the player's ship matches that used in the Space Mountain roller coaster at the theme park.</p>
<p>I've read that some versions of the game have a very different introduction that specifically mentions Disneyland. Although I have never played such a version, I did find some unused audio files packed in the game's data archives in which a narrator does indeed mention the theme park by name. The narrator also establishes the game's premise: the player was the unwitting passenger on the Space Mountain ship as it was accidentally activated and departed Earth. (This game story was ultimately replaced by the one in which the ship crash-lands on Earth, and the player is an operative assigned by a shadowy international intelligence organization.)</p>
<p>The Disney connection may also help to explain the support for the Disney Sound Source hardware, which was otherwise not popular among game developers.</p>
<h2 id="dat-archive-format">DAT archive format</h2>
<p>Apart from the main executable, NOMAD.EXE, the only interesting files are the five data archives:</p>
<ul>
<li>ANIM.DAT</li>
<li>CONVERSE.DAT</li>
<li>INVENT.DAT</li>
<li>SAMPLES.DAT</li>
<li>TEST.DAT</li>
</ul>
<p>Each of these contains a number of compressed data files, generally grouped into categories: animations, conversation/mission text and data tables, inventory item images, audio, and everything else (including color palettes, other static images, and 3D models). The DAT archive format starts with a 16-bit count of the number of contained files. Immediately following this is an index with one 28-byte index entry per file. Each index entry is formatted like so:</p>
<pre><code>uint16_t flags;
uint32_t uncompressed_size;
uint32_t compressed_size;
char filename[14]; // includes null terminator
uint32_t offset;
</code></pre>

<p>At least two of the flag bits are important for indicating the compression method used to store the file:</p>
<ul>
<li><strong>flags.8</strong> indicates whether the file is stored with the LZ compression algorithm described below. If this bit is clear, the <code>uncompressed_size</code> and <code>compressed_size</code> fields must match. In this case, the file is uncompressed and its content may be copied byte-for-byte from the .DAT.</li>
<li><strong>flags.2</strong> indicates whether the file is stored with uncompressed header data. If this bit is set, the entirety of the file's data is stored with LZ compression. If this bit is clear, the first two words (four bytes) are uncompressed and may be copied directly from the .DAT, leaving the remaining data to pass through LZ decompression. Note that the <code>compressed_size</code> field does <strong>not</strong> include this four-byte header, and as a result, the next file in the .DAT archive will start at <code>offset + compressed_size + 4</code>.</li>
</ul>
<p>The data for the first contained file starts immediately after the last index entry.</p>
<h3 id="lz-compression-algorithm">LZ compression algorithm</h3>
<p>The LZ compressed files themselves are individually deflated with a modified 8-bit Lemper-Ziv (LZ) algorithm. Data is grouped into chunks, and each chunk can consist of either a literal byte, or a back-reference to a string of bytes that was previously encountered during decompression. In this way, byte sequences that repeat can be represented by an abbreviated codeword, thereby saving space.</p>
<p>In addition to the output stream, the algorithm maintains a 4096-byte ring buffer that provides the source of data for the back-references. This buffer must be initialized with all bytes set to 20h, and the offset pointer into the buffer set to FEEh. This pointer value was chosen because it is 18 bytes from the end of the buffer, and that is the maximum length of a single back-reference sequence (as we will see later.) Therefore, at least one chunk will be decoded before the pointer wraps back to the start.</p>
<p>In the compressed source data, each sequence of eight chunks is preceded by a flag byte, in which each bit indicates the nature of one of the following chunks:</p>
<ul>
<li><strong>1:</strong> the chunk is a literal single byte, to be copied directly from the compressed source</li>
<li><strong>0:</strong> the chunk is a two-byte coded back-reference into the ring buffer</li>
</ul>
<p>These bits are checked in order of LSB to MSB. For example, a flag byte of F7h means that the next three chunks are literal, followed by a single reference, then four more literals.</p>
<p>As each byte is copied to the output, it is also copied to the 4K ring buffer. Whenever data is being read from or written to this buffer, the pointer is reset to position 0 when it reaches position 1000h.</p>
<p>To decode a back-reference, read the two-byte sequence as a little-endian pair. It contains two fields:</p>
<ul>
<li>
<p>Byte count (bits 15:12): This four-bit count is actually the length minus three. Because the coded sequence itself occupies two bytes, there is no gain in encoding any fewer than three source bytes. A value of 0 in this field indicates a length of 3, and the max value of Fh indicates a length of 18 (12h).</p>
</li>
<li>
<p>Offset into ring buffer (bits 11:0): A zero-based offset from the start of the 4096-byte ring buffer at which to begin reading the number of bytes specified in the byte count field. As noted, the decoder must start filling this buffer from offset FEEh, so the first few back-references seen in a compressed file may be in this higher range (FEEh to FFFh).</p>
</li>
</ul>
<h2 id="mission-and-conversation-text">Mission and conversation text</h2>
<p>For the most part, the decompressed text in the game is human-readable ASCII, but many of the strings do contain special command bytes used to insert strings or modify game state. For example, a mission posting that mentions a particular alien vessel will grant knowledge of that vessel to the player when he reads the mission text. Once the player has knowledge of a topic, that topic can be used in conversation with aliens to uncover more facts. Mission and conversation text can also have embedded commands that add an item to the player's inventory, or change the alien character's temperament. Following is a table of the supported embedded command bytes and their functions:</p>
<table>
<thead>
<tr>
<th>Command byte</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>Insert the Player's name.</td>
</tr>
<tr>
<td>02</td>
<td>Insert the name of the Player's ship.</td>
</tr>
<tr>
<td>03</td>
<td>Name of current location.</td>
</tr>
<tr>
<td>04</td>
<td>Insert the string <code>&lt;GAMESTR&gt;</code></td>
</tr>
<tr>
<td>05</td>
<td>Insert meta text (e.g. a randomly chosen synonym, Shaasa phrase that may be translated, or Losten gateway code). See sections on META.TAB and METATXT.TAB.</td>
</tr>
<tr>
<td>06</td>
<td>Add one item (specified by the following byte) to the Player's inventory.</td>
</tr>
<tr>
<td>07</td>
<td>Insert the string <code>&lt;METAMOVE&gt;</code></td>
</tr>
<tr>
<td>08</td>
<td>Change temperament of alien speaking the text.</td>
</tr>
<tr>
<td>09</td>
<td>Grant knowledge of fact (specified by the following byte).</td>
</tr>
<tr>
<td>0A</td>
<td>Grant knowledge of place (specified by the following byte or byte pair). If the first byte following the command byte has its MSB clear, then it may be used directly as an index into the Place Table. Otherwise, if the first byte has its MSB set, then it must be combined with the following byte to form the Place Table index: <code>(firstbyte &amp; 7Fh) | (secondbyte &lt;&lt; 7)</code>.</td>
</tr>
<tr>
<td>0B</td>
<td>Set bit 0 in the first byte of the current Alien State Table entry.</td>
</tr>
<tr>
<td>0C</td>
<td>Grant knowledge of item (specified by the following byte).</td>
</tr>
<tr>
<td>0D</td>
<td>Set bit 1 in the first byte of the current Alien State Table entry.</td>
</tr>
<tr>
<td>0E</td>
<td>Copy contents of 'encount_relate2' table to 'encount_relate' table.</td>
</tr>
<tr>
<td>0F</td>
<td>Grant knowledge of race (specified by the following byte).</td>
</tr>
<tr>
<td>10</td>
<td>Modify 'encount_relate' tables in memory.</td>
</tr>
<tr>
<td>11</td>
<td>Grant knowledge of ship (specified by the following byte).</td>
</tr>
<tr>
<td>14</td>
<td>Set alien attribute (friendliness?) to maximum (64h). The alien table entry to be modified is selected by existing pointers in memory.</td>
</tr>
<tr>
<td>15</td>
<td>Set alien attribute (friendliness?) to minimum (00h). The alien table entry to be modified is selected by existing pointers in memory.</td>
</tr>
<tr>
<td>16</td>
<td>Modify mission table state for the mission specified by the following byte. In byte 12 of the MISSION.TAB entry: if bit 1 is set and bit 0 is clear, then set bit 7.</td>
</tr>
</tbody>
</table>
<h2 id="palettes">Palettes</h2>
<p>The palette data is stored in a number of .PAL files in the TEST.DAT archive. Each contains a three-byte header in which the first byte appears to always be 00h. The second byte is the VGA palette index at which the color data should be written. The third byte holds the number of palette entries, but only in the smaller palettes; it is 00h for the 256-color files. After this short header, the colors follow as 6-bit RGB triplets, with one color component per byte. Each palette is one of two different sizes:</p>
<ul>
<li>64 colors (3 byte header, 3 bytes per color, 195 bytes total)</li>
<li>256 colors (3 byte header, 3 bytes per color, 771 bytes total)</li>
</ul>
<p>A common convention for converting 6-bit RGB data to the more ubiquitous 8-bit RGB data involves shifting the value left by two, and then replicating the top two bits in the lower two:
<code>r = (r_raw &lt;&lt; 2) | (r_raw &gt;&gt; 4);</code></p>
<p>The starting palette index is important because image data can use colors from any location in the VGA palette (which is defaulted by the graphics hardware BIOS.) Different elements in the game use different index ranges in the palette. The planet textures use up to 64 colors in the range 80h to BFh. The 3D ship models use the range C0h to FFh.</p>
<h2 id="static-image-data">Static image data</h2>
<h3 id="inventory-objects-and-overlay-images-stp">Inventory objects and overlay images (.STP)</h3>
<p>Most of the images in Nomad are stored as run-length-encoded (RLE) data with 8 bits per pixel, indexing into a palette. (Note that the RLE compression is another layer inside the LZ compression of the archive, so many of these files are effectively compressed twice.) Images in this format are stored with a filename using the ".stp" extension, which is likely a proprietary format created for the game.</p>
<p>The STP image format has very little header information: it stores only the image width and height as little-endian 16-bit values in the first four bytes. The files I've used for testing all had zeroes in the following four bytes, and then image data starting at offset 0008. Each chunk of data in the file starts with a runlength byte, which describes that chunk as being one of three types:</p>
<ul>
<li><strong>Pointer advance / background:</strong> Marked by bit 7 being set (bitmask 80h). In the game engine, this simply advances the pointer in the output buffer by the number of bytes specified in the lower seven bits of this RLE byte (bitmask 7Fh). For example, B8h will advance the output pointer by 38h bytes. The effect of this is that the existing content of the output buffer will persist, unchanged by the decoding sequence. The game engine can prefill the buffer with whatever values is appropriate for the type of image being displayed. In the case of inventory items, the buffer is mostly filled with 00h. The color at index 00h in most of the game's palettes is black, which provides a black background for the image.</li>
<li><strong>Repeat byte from input:</strong> Marked by bit 7 being clear and bit 6 being set. This loads the next byte from the input buffer, and repeats it to the output buffer the number of times specified in the lower six bits of this RLE byte (bitmask &amp; 3Fh).</li>
<li><strong>Direct byte sequence copy from input:</strong> Marked by both bits 7 and 6 being clear. This copies the next <em>n</em> bytes, in sequence, from the input, where <em>n</em> is the value of this RLE byte.</li>
</ul>
<h3 id="planet-surface-textures-pln">Planet surface textures (.PLN)</h3>
<p>The image data that represents the surface of planets is stored in the TEST.DAT archive as a series of .pln files. Each .pln file has at least one palette file (.pal) associated with it, and most of the .pln files have multiple possible palettes.</p>
<p>The image files are named "WORLD##a.pln", where ## is a two-digit, zero-prefixed decimal number in the range 00-50 (skipping 21, 22, and 23). The associated palette filenames use the .pal extension. They start with the same seven characters, but the lowercase '<em>a</em>' suffix is incremented for every associated palette beyond the first. For example, WORLD20a.pln can use any palette from WORLD20a.pal through WORLD20m.pal. (WORLD20 happens to have the greatest number of associated palette files, at thirteen -- <em>a</em> through <em>m</em>.)</p>
<p>Inside each .pln file is an uncompressed 8-bit palette-indexed image. They are all the same size at 200x100 pixels. The only header information is a single little-endian 16-bit word containing the number of pixels per line. All .pln files therefore have the same header (C8 00) and same filesize, at 20002 bytes.</p>
<p>The mapping between planet IDs and their texture/palette files is not done by a data file, but a hardcoded table in the game's executable. In my copy, it appears as a series of two-byte pairs at offset <code>DS:51F4</code> (or <code>35384h</code> in the binary.) The index of the pair matches the ID of the planet (see PLACE.TAB, below). The first byte in each pair is the base number for the texture/palette filename, and the second byte is the lower-case alpha character used as a suffix to select one of the multiple palette files. Places that are not valid travel destinations (i.e. the stars) do not have surface textures that are rendered in game, and their entries in this table are zeroed.</p>
<h2 id="alien-animations">Alien animations</h2>
<p>The aliens shown during conversation are drawn using composite animation frames built up from several different overlays. Each frame typically starts with a background image, over which different segments of the alien are drawn to create a complete picture. The alien's head, body, hands, and facial expressions are animated separately to allow for flexibility. Different color palettes are also available, allowing for a large amount of variety in building unique aliens by mixing different combinations of body parts and palettes.</p>
<p>Alien speech audio is (more or less) synchronized with the animation to complete the effect.</p>
<h3 id="del-files">DEL files</h3>
<p>The .DEL files contain the actual raster image data for the aliens and backgrounds. The first two words contain the image width and height, respectively. (The width and height must be the same for all .DEL files associated with a given alien race.) Each of the remaining data chunks in the file are one of four different types, and the type is determined by the lowest two bits of the first byte in the chunk (which hereafter is referred to as the "command byte"):</p>
<table>
<thead>
<tr>
<th>Cmd byte &amp; 3</th>
<th>Sequence type</th>
<th>Decode procedure</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Delta encoded</td>
<td>Determine a sequence length by isolating the top six bits of the command byte (cmd &gt;&gt; 2). The first byte of output in this sequence is copied directly from the input stream. For each of the following bytes: read the next nibble from the input stream (starting with the high order nibble in each byte), and use its value to index into a hardcoded table that provides the deltas (see below). Add this delta to the value of the last byte that was written to the output, and write the result as the next byte in the output.</td>
</tr>
<tr>
<td>01</td>
<td>Repeat byte</td>
<td>Copy the next single byte from the input to the output buffer <em>n</em> times, where <em>n</em> is (cmdbye &gt;&gt; 2).</td>
</tr>
<tr>
<td>10</td>
<td>Advance output</td>
<td>Shift the command byte right by two to isolate the top six bits (cmdbyte &gt;&gt; 2). If this value is nonzero, add it to the output buffer index. Otherwise, if the value in the top six bits is zero, read the next byte from the input and add its value to the output buffer position pointer. The effect of this is that the existing values are left at the skipped output buffer locations, in effect creating a transparency in the current layer.</td>
</tr>
<tr>
<td>11</td>
<td>Single copy</td>
<td>Copy a single byte from the input to the output buffer.</td>
</tr>
</tbody>
</table>
<h4 id="delta-table">Delta table</h4>
<table>
<thead>
<tr>
<th>Index:</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>Delta:</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>-8</td>
<td>-7</td>
<td>-6</td>
<td>-5</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
</tr>
</tbody>
</table>
<h3 id="anm-files">ANM files</h3>
<p>The ANM files contain index information that is used to build composite frames and sequence them together. An ANM file describes all the frames for a particular alien. The mapping between an alien's ID and its ANM file is done by a hardcoded table of 206 words at <code>DS:2F20</code>. Each word points to a string in memory that forms the basis for a filename ("ARD15", "KOR02", "PHE20", etc.) to which the suffix <code>.ANM</code> is then added. The player's own character does not have an ANM file because the player is not shown during normal gameplay.</p>
<h4 id="header">Header</h4>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-0C</td>
<td>Null-terminated string containing the name of the palette file associated with this animation set</td>
</tr>
<tr>
<td>0D-19</td>
<td>Null-terminated string containing the name of a .ROL file that appears to be unused</td>
</tr>
</tbody>
</table>
<h4 id="data">Data</h4>
<p>This section contains two groups of 64 records, each record being sixteen bytes long (but with all unused bytes set to FFh). Any record that is completely unused will be zeroed.</p>
<p>In the first group, each record describes one complete frame, and lists the partial frames that are layered together to create it. Each byte in the record points to a single <code>.del</code> file that are together drawn in sequence to complete the frame. The .del filename is in the format <code>xx####.del</code>, where <em>xx</em> is the first two characters of the alien race (in lowercase) and <em>####</em> is a zero-prefixed decimal representation of the .del number. (Examples: ar0003.del, mu0051.del)</p>
<p>The second group of ANM records begins at byte offset <code>41Ah</code>. The first byte of these records contains three fields:</p>
<ul>
<li>Bits 1-0: Alien temperament (equal to 1, 2, or 3)</li>
<li>Bits 3-2: <code>01</code> in the first of several records for a temperament group, <code>10</code> for all records within that group, and <code>11</code> in the last record of that group</li>
<li>Bits 7-4: Typically increments for each record within a temperament group</li>
</ul>
<p>I haven't confirmed the meaning of subsequent bytes in these records, but it's likely that they point to the composite frame numbers established by the first group of records in the same ANM file.</p>
<h3 id="sqb-files">SQB files</h3>
<p>These appear to be used to synchronize voice sound effects with the animations. There is a a single .SQB file per alien race (with the exception of Human and Kenelm.) All SQB files are in the same format and are of the same length.</p>
<h4 id="header_1">Header</h4>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-0D</td>
<td>Null-terminated string for associated voice filename</td>
</tr>
<tr>
<td>0E-0F</td>
<td>Number of 24-byte records in the SQB file that are used. This is 21 (15h) for all races other than Korok, and 11 (0Bh) for Korok.</td>
</tr>
</tbody>
</table>
<h2 id="sound">Sound</h2>
<p>The game's audio files are packed into .NNV containers, stored in SAMPLES.DAT and TEST.DAT. The container format itself is very simple: the first byte is the number of contained files, and it is immediately followed by pairs of 32-bit words that contain the starting offset and size, respectively, for each of the files in the container. For example, an .NNV that contains four files will have a header of 33 bytes (one byte for the file count, plus four sets of two 32-bit words). Note that some NNVs have index entries that refer to contained files of zero length. This is valid, and simply means that the following file's data will start at the same offset as the zero-length file.</p>
<p>The sound data itself is encoded with a 4-bit delta PCM scheme. It represents a single channel of unsigned 8-bit PCM audio intended for playback at 7042Hz. (This unusual playback rate is the result of the time constant divisor math that is used by the Sound Blaster DSP programming interface.) The table of PCM delta values used by the algorithm is made up of fifteen sections, with each being sixteen bytes long. In my copy of the game, this table is stored in the main executable at offset <code>29705h</code>, which becomes <code>seg060:1055</code> at runtime.</p>
<p>While doing some research, I found that DPCM delta arrays with the exact same values are used by the 1995 Sega Genesis game <em>Comix Zone</em>, and probably other games as well. It seemed that there must be a common reference that was used by the developers, and I then found that <em>The Data Compression Book</em> (Nelson, 1991) contains a description of audio compression techniques with these precise delta values in an example. They are derived from the following exponential transfer function:</p>
<p><code>output = 127.0 * ( pow(2.0, input / max_input_val) - 1.0 )</code></p>
<h3 id="decoding-dpcm-audio">Decoding DPCM audio</h3>
<p>The DPCM encoded data is read one nibble at a time, starting with the high nibble first. When a nibble of value <code>0</code> is encountered, the following nibble is used as an index to select one of the fifteen delta tables. Otherwise, when a nonzero nibble is encountered, it is used as an index into the currently selected delta table, and the resultant delta value is then added to the last byte written to this output. (This signed 8-bit value is allowed to wrap.) This becomes the next byte to write to the output. At the start of decoding, the "last value" is considered to be <code>80h</code>.</p>
<p>When the nibble sequence <code>0 F</code> is encountered, this cannot be used to set the delta table index because the value <code>F</code> is beyond the index range. Instead, this sequence is interpreted as a command to repeat the last byte that was written to the output. To get the repeat count, the next two nibbles are read and combined into a single 8-bit value (regardless of whether they shared the same byte in the input stream.) If this value is 0, it is interpreted as a repeat count of 256. After repeating the last output byte this number of times, decoding continues with reading the next nibble from the input.</p>
<p>Example input sequence: <code>03 40 F0 41</code></p>
<ul>
<li>Read nibble <code>0</code>, which indicates the start of a command sequence.</li>
<li>Read nibble <code>3</code>. This is less than <code>F</code>, so it is used to select the fourth section of the delta table.</li>
<li>Read nibble <code>4</code>. Because this is not zero, it is used to select a single delta value from the currently selected delta table. In this case, the delta is <code>-Bh</code>. This delta is added to the last output value (which we assume to be <code>80h</code>) to create the next output value of <code>75h</code>. This byte is written to the output stream.</li>
<li>Read nibble <code>0</code>, which indicates the start of a command sequence.</li>
<li>Read nibble <code>F</code>. This is the byte-repeat command. The next two nibbles are read and combined into a single 8-bit value (<code>04h</code>) that is used as the repeat count. The last byte written to the output (<code>75h</code>) is repeated to the output this number of times.</li>
<li>Read nibble <code>1</code>. This is another delta value selection. We are still using the same delta table section selected by the first two nibbles in this input stream, and the delta value at position <code>1</code> in that section happens to be <code>-17h</code>. This is added to <code>75h</code> to compute the next output value of <code>5Eh</code></li>
</ul>
<p>This example input stream generates the following output: <code>75 75 75 75 75 5E</code></p>
<h2 id="data-tables">Data tables</h2>
<p>Nomad has a series of data tables that are read into memory and used to define attributes for ships, planets, aliens, inventory objects, engineering upgrades, and other aspects of the game. In addition to defining the initial state of the game universe, many of these tables contain fields that are updated dynamically while the game is being played; for example, the Object Table entries each contain a flag that is set when the player is granted knowledge of that object. When a player saves his progress, a .SAV file is created that contains a subset of the game's data tables plus some additional dynamic data. The .SAV files also include a few discrete pieces of data, such as the number of Korok vessels that have been destroyed, and a boolean flag indicating whether the Altec Hocker have been discovered by the player.</p>
<h3 id="enumerations-and-indexing">Enumerations and indexing</h3>
<p>The game engine makes frequent use of enumerations to index table records. One of the more commonly encountered enums is that for the alien races:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Race</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Altec Hocker</td>
</tr>
<tr>
<td>01</td>
<td>Arden</td>
</tr>
<tr>
<td>02</td>
<td>Bellicosian</td>
</tr>
<tr>
<td>03</td>
<td>Chanticleer</td>
</tr>
<tr>
<td>04</td>
<td>Human</td>
</tr>
<tr>
<td>05</td>
<td>Kenelm</td>
</tr>
<tr>
<td>06</td>
<td>Korok</td>
</tr>
<tr>
<td>07</td>
<td>Musin</td>
</tr>
<tr>
<td>08</td>
<td>Pahrump</td>
</tr>
<tr>
<td>09</td>
<td>Phelonese</td>
</tr>
<tr>
<td>0A</td>
<td>Shaasa</td>
</tr>
<tr>
<td>0B</td>
<td>Ursor</td>
</tr>
</tbody>
</table>
<p>The data tables that keep track of planets, ships, aliens, objects, etc. do not make use of the record at index 0. An index of 0 is typically interpreted by the code as "unused" or "invalid". This effectively means that most tables have 1-based indexing.</p>
<p>Many of the data tables describe locations, people, or objects that have a name used in-game. Most of these names are stored in GAMETEXT.TXT, and I found that the first word of data table entries is often an offset into GAMETEXT.</p>
<h3 id="alientab">ALIEN.TAB</h3>
<ul>
<li>Total size: 2048 (800h) bytes</li>
<li>Record size: 8 bytes</li>
<li>Record count: 256 (100h), of which 206 (CEh) are used, including one for the Player</li>
</ul>
<p>In addition to the many aliens that are actually encountered during the game, ALIEN.TAB contains entries for the mythical figures from the legends told by the different alien species. For some reason, these characters are all assigned Chanticleer portrait animations, but this is of no consequence since they do not appear during gameplay.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of alien. Offset into GAMETEXT.TXT for null-terminated string.</td>
</tr>
<tr>
<td>02</td>
<td>Alien race.</td>
</tr>
<tr>
<td>03</td>
<td>Bytes 03 through 07 contain apparent percentage/scaling values, with the lowest being 00h and the highest being 64h.</td>
</tr>
</tbody>
</table>
<h3 id="cclasstab-communication-jammer-table">CCLASS.TAB - Communication Jammer Table</h3>
<ul>
<li>Total size: 20 (14h) bytes</li>
<li>Record size: 2 bytes</li>
<li>Record count: 10 (Ah), of which 4 are used (indices 1 through 4)</li>
</ul>
<h3 id="eclasstab-engine-class-table">ECLASS.TAB - Engine Class Table</h3>
<ul>
<li>Total size: 60 (3Ch) bytes</li>
<li>Record size: 6 bytes</li>
<li>Record count: 10 (Ah), of which 6 are used (indices 1 through 6)</li>
</ul>
<h3 id="facttab">FACT.TAB</h3>
<ul>
<li>Total size: 2048 (800h) bytes</li>
<li>Record size: 16 (10h) bytes</li>
<li>Record count: 128 (80h), 124 used</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Offset into GAMETEXT.TXT for null-terminated string</td>
</tr>
<tr>
<td>02-0D</td>
<td>Byte array indicating each alien race's receptivity to this fact</td>
</tr>
<tr>
<td>0E</td>
<td>Bitfield:<br/>Bit 1: Fact is known by player</td>
</tr>
</tbody>
</table>
<h3 id="inventtab">INVENT.TAB</h3>
<p>First section:</p>
<ul>
<li>Total size: 1024 (400h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 256 (100h)</li>
</ul>
<p>Second section:</p>
<ul>
<li>Total size: 9216 (2400h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 2304 (900h)</li>
</ul>
<p>Total size: 10240 (2800h) bytes</p>
<p>This table describes the inventory contents of each ship in the game. It is divided into two sections, both with four-byte records. The first section has 256 records -- one for each slot in the Ship Table -- and each record stores a pointer to the start of a linked list of records in the second section. The second section contains these linked list nodes, with each node containing an item ID, count, and link to the next node.</p>
<p>The index of the Player's Ship is <code>FFh</code> (i.e. last position in the Ship Table), so the player's inventory list starts with a pointer stored in the last record of the Inventory Table's first section.</p>
<p>First section:</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Unused; fixed at 00</td>
</tr>
<tr>
<td>01</td>
<td>Number of item records associated with this ship</td>
</tr>
<tr>
<td>02-03</td>
<td>Index of first record for this ship's inventory. This must be multiplied by the record size (4 bytes) to get the offset into INVENT.TAB.</td>
</tr>
</tbody>
</table>
<p>Second section:</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Object ID</td>
</tr>
<tr>
<td>01</td>
<td>Count</td>
</tr>
<tr>
<td>02-03</td>
<td>Index of next record for the current ship's inventory. This must be multiplied by the record size (4 bytes) to get the offset into INVENT.TAB.</td>
</tr>
</tbody>
</table>
<h3 id="lboostertab-labor-botbooster-data">LBOOSTER.TAB - Labor Botbooster Data</h3>
<ul>
<li>Total size: 60 (3Ch) bytes</li>
<li>Record size: 6 bytes</li>
<li>Record count: 10 (Ah), of which 6 are used (indices 1 through 5, and 7)</li>
</ul>
<h3 id="lclasstab-labor-bot-class-data">LCLASS.TAB - Labor Bot Class Data</h3>
<ul>
<li>Total size: 120 (78h) bytes</li>
<li>Record size: 12 (0Ch) bytes</li>
<li>Record count: 10 (Ah), of which 6 are used (indices 1 thorugh 6)</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>05</td>
<td>Gas collection efficiency</td>
</tr>
<tr>
<td>06</td>
<td>Ore collection efficiency</td>
</tr>
<tr>
<td>07</td>
<td>Farming efficiency</td>
</tr>
<tr>
<td>08</td>
<td>Ranching efficiency</td>
</tr>
<tr>
<td>09</td>
<td>Archaeological efficiency</td>
</tr>
<tr>
<td>0A</td>
<td>Spy efficiency</td>
</tr>
</tbody>
</table>
<h3 id="mclasstab-missile-class-table">MCLASS.TAB - Missile Class Table</h3>
<ul>
<li>Total size: 40 (28h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 10 (Ah), of which 4 are used (indices 1 thorugh 4)</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>03</td>
<td>Power</td>
</tr>
</tbody>
</table>
<h3 id="metatab">META.TAB</h3>
<ul>
<li>Total size: 276 (114h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 69 (45h), of which 64 are used (indices 0 through 63)</li>
</ul>
<p>The meta-text system in Nomad allows the game to randomly select from several equivalent phrases when building alien conversation text, thereby adding some variety to the dialogue. The text strings themselves are stored in GAMETEXT.TXT, and the offsets to them are stored in METATXT.TAB. This table -- META.TAB -- defines the type of each meta text section as well as the number of synonymous phrases available in each.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Number of different possible selections for this meta text entry.</td>
</tr>
<tr>
<td>01</td>
<td>Type of meta text. Three possible types are used by the game:<br/><br/>00h: Normal conversational synonym (e.g. the Musin will randomly select from the words "dastardly", "nefarious", "villainous", and "contemptible" when cursing someone of low moral fibre)<br/><br/>01h: Translation. About a dozen different words spoken by the Shaasa in their native language are automatically translated if the player has the Proto Uni-Translator in his inventory.<br/><br/>02h: Losten gateway code. Because the codes are generated randomly during each playthrough, this marker is used to generate a code (or recall a previously generated code.)</td>
</tr>
<tr>
<td>02-03</td>
<td>Index of record in METATXT.TAB. Multiply by 2 to compute byte offset in that file.</td>
</tr>
</tbody>
</table>
<h3 id="metatxttab">METATXT.TAB</h3>
<ul>
<li>Total size: 460 (1CCh) bytes</li>
<li>Record size: 2 bytes</li>
<li>Record count: 230 (E6h), of which 226 are used (indices 0 through 225)</li>
</ul>
<p>This table is a simple list of 230 16-bit offsets into GAMETEXT.TXT. Each of the offsets points to the start of a string in the "meta" text section at the beginning of GAMETEXT. These text fragments fall into groups, and each group defines equivalent phrases from which the game will pick randomly while building alien conversation text.</p>
<p>Note that this file contains an offset for each individual meta text string (not merely the first string in each group). The indices for strings that belong to the same meta group are all contiguous in the file.</p>
<h3 id="missiontab-mission-table">MISSION.TAB - Mission Table</h3>
<ul>
<li>Total size: 3072 (C00h) bytes</li>
<li>Record size: 24 (18h) bytes</li>
<li>Record count: 128 (80h), 100 used</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Place ID of the location that the Player must visit to either obtain or deliver a mission item</td>
</tr>
<tr>
<td>0F</td>
<td>ID of other mission -- prerequisite?</td>
</tr>
<tr>
<td>10</td>
<td>Action required:<br/>00: No action required<br/>02: Destroy ship<br/>03: Deliver item</td>
</tr>
<tr>
<td>11</td>
<td>ID of target ship, or ID of required inventory object</td>
</tr>
<tr>
<td>14-15</td>
<td>Index of MISTEXT.IDX record for text of mission start (multiply by 4 and add 4 for MISTEXT.IDX offset)</td>
</tr>
<tr>
<td>16-17</td>
<td>Index of MISTEXT.IDX record for text of mission completion (multiply by 4 and add 4 for MISTEXT.IDX offset)</td>
</tr>
</tbody>
</table>
<h3 id="mistextidx-mission-text-index">MISTEXT.IDX - Mission Text Index</h3>
<ul>
<li>Total size: 804 (324h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 200 (C8h)</li>
</ul>
<p>Table of 32-bit offsets into MISTEXT.TXT, each one pointing to the start of a string containing mission text. In this file, the first two bytes are zeroed, followed by a 16-bit little-endian word containing the number of records in the file. The records containing the 32-bit offsets then follow immediately.</p>
<h3 id="mistextidx-mission-text">MISTEXT.IDX - Mission Text</h3>
<p>Contains gametext that describes Alliance missions, both to start missions and acknowledge their completion.</p>
<h3 id="msystab-missile-system-table">MSYS.TAB - Missile System Table</h3>
<ul>
<li>Total size: 20 (14h) bytes</li>
<li>Record size: 2 bytes</li>
<li>Record count: 10 (Ah)</li>
</ul>
<h3 id="objecttab-inventory-object-table">OBJECT.TAB - Inventory Object Table</h3>
<ul>
<li>Total size: 6144 (1800h) bytes</li>
<li>Record size: 24 (18h) bytes</li>
<li>Record count: 256 (1000h)</li>
</ul>
<p>This table contains information about the game's inventory objects. It also reveals some interesting elements and a significant bug:</p>
<ul>
<li>In agreement with the storyline, the Altec Hocker do not place any value on any material items.</li>
<li>There are a few objects that might only be used as placeholders since they do not physically appear in-game. These include "The Alliance", "Facts", "The Volm", and the W.A.P.. The first three of these actually have images, although they look like unused images for items that were removed from the game.</li>
<li>The Farm-Bot Aquatic Kit has an entry and an image, but the image appears to have been left unfinished by the artist.</li>
<li>The relative-value fields for the Korok and the Kenelm are swapped! This is very apparent when inspecting the data. Based on the storyline, the Kenelm <em>should</em> place maximum value on the Eye of Kenelm but no value on any other object, while the Korok should place value primarily on raw materials and tactical equipment. However, exactly the opposite is true in the OBJECT.TAB data. Although this is a bug in the game, it only manifests as a tendency for the Korok to accept strange items in trade that shouldn't actually interest them.</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of object. Offset into GAMETEXT.TXT for null-terminated string.</td>
</tr>
<tr>
<td>02-03</td>
<td>?</td>
</tr>
<tr>
<td>04-05</td>
<td>?</td>
</tr>
<tr>
<td>06</td>
<td>Boolean flag indicating whether the item is tradeable.</td>
</tr>
<tr>
<td>07</td>
<td>?</td>
</tr>
<tr>
<td>08</td>
<td>Bit 7 is a flag indicating that the item is unique. The rest of the byte is a single 7-bit value:<br/>00: Normal item without a special purpose<br/>01: Normal item, but with informational text (via OBJTEXT.IDX / OBJTEXT.TXT)<br/>02: Engine<br/>03: Scanner<br/>04: Jammer<br/>05: Shield<br/>06: Missile<br/>07: Missile loader<br/>0A: Ship botbooster<br/>0B: Labor bot<br/>0C: Labor bot enhancement (botbooster or aquatic kit)<br/>0D: Award/medal/recognition<br/>0E: Translator (used only by Proto Uni-translator)</td>
</tr>
<tr>
<td>09</td>
<td>Multipurpose ID information.<br/>If the item is of type 01 (i.e. it has informational text associated with it), then the value in this field is used as an index to a 4-byte record in OBJTEXT.IDX, which in turn provides an offset into OBJTEXT.TXT for the text. Otherwise, if the item is of another type, this field is interpreted as an enum value that maps to the different levels of shields, missiles, scanners, etc.</td>
</tr>
<tr>
<td>0A</td>
<td>Bitfield. Bit 2 indicates that the object is known by the player.</td>
</tr>
<tr>
<td>0B-16</td>
<td>Array of byte values indicating the desirability of the object to each of the game's alien races. The range of values per byte in this array is 00-64h. Indexing into the array is done with the same alien race enum that is used elsewhere in the game.</td>
</tr>
<tr>
<td>17</td>
<td>Unused</td>
</tr>
</tbody>
</table>
<h3 id="pclasstab-place-class-data">PCLASS.TAB - Place Class Data</h3>
<ul>
<li>Total size: 3072 (C00h) bytes</li>
<li>Record size: 48 (30h) bytes</li>
<li>Record count: 64 (40h), of which 52 (34h) are used</li>
</ul>
<p>The names are descriptive of the planet type or its attributes ("Barren", "Ice Planet Type A", "Abandoned", etc.)</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of place class. Offset into GAMETEXT.TXT for null-terminated string. This will be a description of the place class like "Barren", "Ice Planet Type A", etc.) The description may also be "Sentient Life Forms", which is used for Alchem (home of the Kenelm.)</td>
</tr>
<tr>
<td>06-07</td>
<td>Temperature. Signed 16-bit value that is described by the game engine as being in one of six ranges:<br/>Below -120: Arctic<br/>-120 to 39: Frozen<br/>40 to 99: Temperate<br/>100 to 149: Tropic<br/>150 to 899: Searing<br/>Above 899: Molten</td>
</tr>
<tr>
<td>09</td>
<td>Nonzero if the planet class is inhabited. If the class is uninhabited, it is considered "Previously Inhabited" only if archaeological artifacts are present.</td>
</tr>
<tr>
<td>0A</td>
<td>Class type:<br/>01: Terran<br/>02: Gas<br/>03: Gas giant<br/>04: Ice<br/>05: Molten<br/>06: Water<br/>0A: Home of sentient life (Alchem)</td>
</tr>
<tr>
<td>0B-0D</td>
<td>Object IDs of farmable foods</td>
</tr>
<tr>
<td>0E-10</td>
<td>Agriculture for each of the farmable foods:<br/>0: None<br/>1 to 19: Barren<br/>20 to 79: Arable<br/>80 or above: Fertile</td>
</tr>
<tr>
<td>11-13</td>
<td>Object IDs of ore/minerals</td>
</tr>
<tr>
<td>14-16</td>
<td>Concentration of each of the ore/minerals:<br/>0: None<br/>1 to 19: Trace<br/>20 to 59: Moderate<br/>60 to 100: Abundant<br/>100 and above: ?</td>
</tr>
<tr>
<td>17-19</td>
<td>Object IDs of archaeological artifacts</td>
</tr>
<tr>
<td>1A-1C</td>
<td>Concentration of each of the archaeological artifacts:</td>
</tr>
<tr>
<td>1D-1F</td>
<td>Object IDs of atmospheric gases</td>
</tr>
<tr>
<td>20-22</td>
<td>Concentration of each of the atmospheric gases:<br/>0: None<br/>1 to 39: Thin<br/>40 to 59: Moderate<br/>60 or above: Dense</td>
</tr>
<tr>
<td>23-25</td>
<td>Object IDs of livestock animals</td>
</tr>
<tr>
<td>26-28</td>
<td>Concentration of each of the livestock animals:<br/>0: None<br/>1 to 39: Sparse<br/>40 to 59: Moderate<br/>60 or above: Plentiful</td>
</tr>
<tr>
<td>29-2B</td>
<td>Object IDs of intelligence items owned by the planet's current inhabitants (e.g. computer banks, diplomatic pouches)</td>
</tr>
<tr>
<td>2C-2E</td>
<td>Concentration of each of the inhabitants' intelligence items</td>
</tr>
</tbody>
</table>
<h3 id="placetab">PLACE.TAB</h3>
<ul>
<li>Total size: 5120 (1400h) bytes</li>
<li>Record size: 16 (10h) bytes</li>
<li>Record count: 320 (140h)</li>
</ul>
<p>Each entry describes a "place", which is a star or planet (or artificial space station, with the single example of this being Second Harmony.) The stars themselves are not valid travel destinations within the game, but they still have attributes that are recorded within this table. Of the 320 slots, only 310 are used by the game.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of place. Offset into GAMETEXT.TXT for null-terminated string.</td>
</tr>
<tr>
<td>02-03</td>
<td>Bits:<br/>0: ?<br/>1: Known by player<br/>2: ?<br/>3: Labor robot site</td>
</tr>
<tr>
<td>04</td>
<td>Place class (index into PCLASS.TAB; multiply by 30h to get PCLASS offset)</td>
</tr>
<tr>
<td>05</td>
<td>Place type: 00h for star, 01h for planet</td>
</tr>
<tr>
<td>06</td>
<td>Place table index for parent star</td>
</tr>
<tr>
<td>08</td>
<td>Planet representative (ALIEN.TAB index; multiply by 8 for ALIEN.TAB offset)</td>
</tr>
<tr>
<td>09</td>
<td>Race</td>
</tr>
<tr>
<td>0A-0B</td>
<td>This word (and the two that follow it) appear to control the drawing locations for stars and planetary orbit tracks in the graphical navigation map.</td>
</tr>
<tr>
<td>0C-0D</td>
<td></td>
</tr>
<tr>
<td>0E-0F</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="podclasstab-unused">PODCLASS.TAB - Unused</h3>
<p>This table is unused by the game. It is populated entirely with zeroes.</p>
<h3 id="rclasstab-robot-class-table">RCLASS.TAB - Robot Class Table</h3>
<ul>
<li>Total size: 20 (14h) bytes</li>
<li>Record size: 2 bytes</li>
<li>Record count: 10 (Ah), of which 5 are used (indices 1 through 5)</li>
</ul>
<p>Data for ship-repair robots. Each record only contains a single value, which translates to the robots' effectiveness.</p>
<h3 id="scclasstab-scanner-class-table">SCCLASS.TAB - Scanner Class Table</h3>
<ul>
<li>Total size: 60 (3Ch) bytes</li>
<li>Record size: 6 bytes</li>
<li>Record count: 10 (Ah), of which 6 are used (indices 1 through 6)</li>
</ul>
<h3 id="sclasstab-ship-class-table">SCLASS.TAB - Ship Class Table</h3>
<ul>
<li>Total size: 384 (180h) bytes</li>
<li>Record size: 12 (0Ch) bytes</li>
<li>Record count: 32 (20h)</li>
</ul>
<p>The Altec Hocker have their own ship class, despite the fact that they do not have physical ships.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of ship class. Offset into GAMETEXT.TXT for null-terminated string.</td>
</tr>
<tr>
<td>02</td>
<td>Starting missile quantity/capacity?</td>
</tr>
<tr>
<td>03</td>
<td>Missile armament type. 00 = None.</td>
</tr>
<tr>
<td>04</td>
<td>Missile loader/system type</td>
</tr>
<tr>
<td>05</td>
<td>Shield type</td>
</tr>
<tr>
<td>06</td>
<td>Scanner type</td>
</tr>
<tr>
<td>07</td>
<td>Engine type</td>
</tr>
<tr>
<td>08-09</td>
<td>Starting shield (or hull?) strength</td>
</tr>
<tr>
<td>0A-0B</td>
<td>Starting hull (or shield?) strength</td>
</tr>
</tbody>
</table>
<h3 id="shclasstab-shield-class-table">SHCLASS.TAB - Shield Class Table</h3>
<ul>
<li>Total size: 40 (28h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 10 (Ah), of which 7 are used (indices 1 through 7)</li>
</ul>
<h3 id="shiptab-ship-data">SHIP.TAB - Ship Data</h3>
<ul>
<li>Total size: 17920 (4600h) bytes</li>
<li>Record size: 70 (46h) bytes</li>
<li>Record count: 256 (100h), of which 255 are used (including one for the Player's Ship)</li>
</ul>
<p>The last entry is for the player's own ship, and the game executable has several routines with hardcoded access to specific fields in this record (at offset <code>45BAh</code>).</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of ship. Offset into GAMETEXT.TXT for null-terminated string.</td>
</tr>
<tr>
<td>02</td>
<td>Pilot (index into ALIEN.TAB)</td>
</tr>
<tr>
<td>03</td>
<td>Ship class (index into SCLASS.TAB)</td>
</tr>
<tr>
<td>04-05</td>
<td>Bitfield. If bits 3, 9 or 13 are set, the vessel will not respond to communication hails.</td>
</tr>
<tr>
<td>06-07</td>
<td>Offset</td>
</tr>
<tr>
<td>22-23</td>
<td>Location (index into PLACE.TAB)</td>
</tr>
<tr>
<td>24-25</td>
<td>Pointer to another ship table entry for a ship that is somehow engaged with this one (targeting/hailing).</td>
</tr>
<tr>
<td>26</td>
<td>Weapon type</td>
</tr>
<tr>
<td>27</td>
<td>Weapon system damage (0 to 64h)</td>
</tr>
<tr>
<td>28</td>
<td>Missile loader type</td>
</tr>
<tr>
<td>2A</td>
<td>Downcounter that is periodically decremented during the missile loading process. Reaches zero when a missile is loaded and the pilot may attempt missile lock.</td>
</tr>
<tr>
<td>2B</td>
<td>Currently loaded missile type</td>
</tr>
<tr>
<td>2C</td>
<td>Downcounter that is periodically decremented during the missile locking process. Reaches zero when missile lock is achieved (i.e. ready to fire.)</td>
</tr>
<tr>
<td>2E-31</td>
<td>Far pointer to another ship table entry</td>
</tr>
<tr>
<td>32</td>
<td>Shield type?</td>
</tr>
<tr>
<td>33</td>
<td>Shield system damage (0 to 64h)</td>
</tr>
<tr>
<td>34</td>
<td>Shield type (index into SHCLASS.TAB)</td>
</tr>
<tr>
<td>35</td>
<td>Shield strength?</td>
</tr>
<tr>
<td>36</td>
<td>Shield-related?</td>
</tr>
<tr>
<td>38</td>
<td>Shield-related?</td>
</tr>
<tr>
<td>3A</td>
<td>Bitfield (or single boolean value)?</td>
</tr>
<tr>
<td>3B</td>
<td>Scanner system damage (0 to 64h)</td>
</tr>
<tr>
<td>3C</td>
<td>Scanner type</td>
</tr>
<tr>
<td>3E-41</td>
<td>Pointer to ?</td>
</tr>
<tr>
<td>42</td>
<td>Engine system damage (0 to 64h)</td>
</tr>
<tr>
<td>43</td>
<td>Engine type</td>
</tr>
<tr>
<td>44</td>
<td>Jammer system damage (0 to 64h)</td>
</tr>
<tr>
<td>45</td>
<td>Jammer type</td>
</tr>
</tbody>
</table>
<h3 id="stclasstab-star-class-table">STCLASS.TAB - Star Class Table</h3>
<ul>
<li>Total size: 96 (60h) bytes</li>
<li>Record size: 6 bytes</li>
<li>Record count: 16 (10h), of which 14 are used (indices 1 through 14)</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Name of star class. Offset into GAMETEXT.TXT for null-terminated string.</td>
</tr>
</tbody>
</table>
<h2 id="talk-files">Talk files</h2>
<p>The game's conversation engine is fed with a large number of data tables. Some of these are common to all individuals of a given alien race, and some are specific to individuals. Entries in the tables reference indices in other tables to create links between lines of dialogue and manage the flow of conversation.</p>
<p>Talk tables with a 'C' as the fifth character of the filename are specific to an individual alien, and the numeric portion of the filename is the ID of that alien. Talk tables with an 'R' in this position are specific only to a race (rather than an individual) and the numeric portion is the enumeration value for that race.</p>
<h3 id="tlkxcxxxtxtidx-and-tlkxrxxxtxtidx">TLKXC<em>xxx</em>.TXT/.IDX and TLKXR<em>xxx</em>.TXT/.IDX</h3>
<p>Collection of strings, where each string is a line of alien dialogue. String data begins at offset 0 in the .TXT and consists of null-terminated strings using the same metatext system as elsewhere in the game.</p>
<p>The .IDX contains a list of 32-bit offsets into the .TXT, each one pointing to the start of a string. In the .IDX file, bytes 00-01 are always zeroed, followed by a 16-bit count (in bytes 02-03) of the total number of offsets in this file. The list of 32-bit offsets follows immediately, so string index 0 actually starts at byte offset 04.</p>
<p>Easter egg: in the file for the player's character ID (TLKXC255.TXT), there is only a single string which was apparently never intended to be seen in-game. It reads, "Go away!!!"</p>
<p>The formats of the TLKXC and TLKXR files are identical, but the game's conversation engine will always check the TLKXC files first and use TLKXR as a fallback if the individual alien table did not have any entries matching the conversation topic.</p>
<h3 id="tlkncxxxtab-and-tlknrxxxtab">TLKNC<em>xxx</em>.TAB and TLKNR<em>xxx</em>.TAB</h3>
<ul>
<li>Record size: 6 bytes</li>
</ul>
<p>These tables contains pointers to lines of dialogue, and optionally can indicate whether a line is a direct question to the player, causing the game to present the player with a pick-list to choose a response.</p>
<p>As with other talk table filenames, the 'C' designates individual-specific and the 'R' race-specific. The first 6-byte record (at index 0) is unused.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Index into TLKXC<em>xxx</em>.IDX or TLKXR<em>xxx</em>.IDX, which in turn points to a line of dialogue</td>
</tr>
<tr>
<td>02</td>
<td>?</td>
</tr>
<tr>
<td>03</td>
<td>Nonzero for the lines that are actually a question to the player. The number in this field is the number of possible responses from which the player can choose.</td>
</tr>
<tr>
<td>04</td>
<td>?</td>
</tr>
<tr>
<td>05</td>
<td>? (always zero?)</td>
</tr>
</tbody>
</table>
<h3 id="tlkprxxxtab">TLKPR<em>xxx</em>.TAB</h3>
<p>The <em>PR</em> talk table creates links between statements and reactions, which is used when the player interactively chooses a response from a list during conversation. This table determines the line of dialogue with which an alien will respond when the player chooses a particular path.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Index in TLKXR<em>xxx</em>.IDX</td>
</tr>
<tr>
<td>02-03</td>
<td>Index in TLKNR<em>xxx</em>.TAB, which then points to an entry in TLKXR<em>xxx</em>.IDX</td>
</tr>
</tbody>
</table>
<h3 id="tlktcxxxtab-and-tlktrxxxtab">TLKTC<em>xxx</em>.TAB and TLKTR<em>xxx</em>.TAB</h3>
<p>Tables of ten-byte records that point to dialogue lines based on topic.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Type indicator:<br/>00: Ask about person, place, or object, or give fact<br/>01: ?<br/>02: Alien sees object in player's inventory<br/>03: Trades for object<br/>04: Display object<br/>05: Greeting (first meeting)<br/>06: Greeting (subsequent meetings)<br/>07: Ask about alien race<br/>08: Give object</td>
</tr>
<tr>
<td>01</td>
<td>Priority. Compared between records, with the highest-numbered record being selected by the game.</td>
</tr>
<tr>
<td>02</td>
<td>Boolean marker used at runtime</td>
</tr>
<tr>
<td>03</td>
<td>Alien ID</td>
</tr>
<tr>
<td>04-05</td>
<td>Place ID</td>
</tr>
<tr>
<td>06</td>
<td>Object ID</td>
</tr>
<tr>
<td>07</td>
<td>Multipurpose ID: alien race if Type field is <code>07</code>, or fact ID if Type field is <code>00</code></td>
</tr>
<tr>
<td>08-09</td>
<td>Index of record in the corresponding TLKNC<em>xxx</em>.TAB or TLKNR<em>xxx</em>.TAB</td>
</tr>
</tbody>
</table>
<h2 id="smfontbin-and-lgfontbin">SMFONT.BIN and LGFONT.BIN</h2>
<p>These contain the raster font data for the small and large fonts, respectively. The first two bytes of each file are the width and height of each character in that font set. LGFONT.BIN is the larger of the two files not only because of the larger character size, but also because it includes both upper- and lower-case alpha characters. SMFONT.BIN contains upper-case only.</p>
<h2 id="sav-file-format">SAV file format</h2>
<p>The sections in the .SAV file:</p>
<table>
<thead>
<tr>
<th>Internal name</th>
<th>Byte offset</th>
<th>Size (bytes, hex)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>(marker bytes)</td>
<td>00</td>
<td>2</td>
<td>Always 07 01</td>
</tr>
<tr>
<td>this_conv</td>
<td>02</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>player_name</td>
<td>06</td>
<td>9</td>
<td>Null-terminated string containing player's name</td>
</tr>
<tr>
<td>player_ship</td>
<td>0F</td>
<td>15</td>
<td>Null-terminated string containing name of player's ship</td>
</tr>
<tr>
<td>current</td>
<td>24</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>setup_tab</td>
<td>2A</td>
<td>2BC</td>
<td></td>
</tr>
<tr>
<td>setup_next_ship</td>
<td>2E6</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>setup_next_free</td>
<td>2E8</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>altec_found</td>
<td>2EA</td>
<td>2</td>
<td>Boolean flag indicating whether the Altec Hocker have been encountered (00 or 01)</td>
</tr>
<tr>
<td>ship_armor</td>
<td>2EC</td>
<td>1</td>
<td>Damage to player's ship armor. 0 is no damage; 100 (64h) is complete damage (i.e. ship is destroyed)</td>
</tr>
<tr>
<td>belicosians_killed</td>
<td>2ED</td>
<td>2</td>
<td>Number of Bellicosian ships destroyed by player</td>
</tr>
<tr>
<td>korok_killed</td>
<td>2EF</td>
<td>2</td>
<td>Number of Korok ships destroyed by player</td>
</tr>
<tr>
<td>ship_heap</td>
<td>2F1</td>
<td>4600</td>
<td>Run-time instance of data from SHIP.TAB</td>
</tr>
<tr>
<td>repair_system</td>
<td>48F1</td>
<td>2</td>
<td>System on player's ship currently being repaired</td>
</tr>
<tr>
<td>current_place</td>
<td>48F3</td>
<td>2</td>
<td>Index in PLACE.TAB of player's current location</td>
</tr>
<tr>
<td>pclass_heap</td>
<td>48F5</td>
<td>C00</td>
<td>Run-time instance of data from PCLASS.TAB</td>
</tr>
<tr>
<td>place_heap</td>
<td>54F5</td>
<td>1400</td>
<td>Run-time instance of data from PLACE.TAB</td>
</tr>
<tr>
<td>object_heap</td>
<td>68F5</td>
<td>1800</td>
<td>Run-time instance of data from OBJECT.TAB</td>
</tr>
<tr>
<td>mission_completed_tab</td>
<td>80F5</td>
<td>80</td>
<td></td>
</tr>
<tr>
<td>mission_heap</td>
<td>8175</td>
<td>C00</td>
<td>Run-time instance of data from MISSION.TAB</td>
</tr>
<tr>
<td>labor_heap</td>
<td>8D75</td>
<td>1C0</td>
<td>Labor robot locations and status</td>
</tr>
<tr>
<td>players_cargo</td>
<td>8F35</td>
<td>14</td>
<td></td>
</tr>
<tr>
<td>invent_heap</td>
<td>8F49</td>
<td>2800</td>
<td>Run-time instance of data from INVENT.TAB</td>
</tr>
<tr>
<td>fact_heap</td>
<td>B749</td>
<td>800</td>
<td>Run-time instance of data from FACT.TAB</td>
</tr>
<tr>
<td>race_killed</td>
<td>BF49</td>
<td>D</td>
<td>Array of player's kill count; single-byte count per species</td>
</tr>
<tr>
<td>race_known</td>
<td>BF56</td>
<td>D</td>
<td>Array of boolean flags indicating whether the player has knowledge of each species in the game (one byte per race)</td>
</tr>
<tr>
<td>astate_heap</td>
<td>BF63</td>
<td>400</td>
<td>State of individual aliens and their relationship to the player</td>
</tr>
<tr>
<td>alien_heap</td>
<td>C363</td>
<td>800</td>
<td>Run-time instance of data from ALIEN.TAB</td>
</tr>
<tr>
<td>encount_relate</td>
<td>CB63</td>
<td>90</td>
<td>Relationship of each alien race with each of the other races</td>
</tr>
<tr>
<td>encount_relate2</td>
<td>CBF3</td>
<td>90</td>
<td></td>
</tr>
<tr>
<td>losten_keys</td>
<td>CC83</td>
<td>4</td>
<td>Array of the four Losten gateway key values, which are stored in the save file since they are randomly generated for each playthrough</td>
</tr>
<tr>
<td>gate_open</td>
<td>CC87</td>
<td>1</td>
<td>Boolean flag indicating whether the Losten gateway has been opened</td>
</tr>
</tbody>
</table>
<h3 id="alien-state-heap-astate_heap">Alien State Heap (astate_heap)</h3>
<ul>
<li>Total size: 1024 (400h) bytes</li>
<li>Record size: 4 bytes</li>
<li>Record count: 256 (100h)
Each record corresponds to a single alien, using the same indexing as ALIEN.TAB.</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Bitfield. Bit 2 indicates that the alien is known by the Player. Bit 3 indicates that the Player and alien have met.</td>
</tr>
<tr>
<td>01</td>
<td>Attitude/temperament:<br/>00h to 1Eh: 1<br/>1Fh to 46h: 3<br/>47h and above: 2</td>
</tr>
<tr>
<td>02</td>
<td>?</td>
</tr>
<tr>
<td>03</td>
<td>?</td>
</tr>
</tbody>
</table>
<h3 id="encounterrelationship-tables-encount_relate-and-encount_relate2">Encounter/Relationship Tables (encount_relate and encount_relate2)</h3>
<ul>
<li>Total size: Two tables, each of 144 (90h) bytes</li>
<li>Record size: 12 (0Ch) bytes</li>
<li>Record count: 12 (0Ch) per table</li>
</ul>
<p>Tracks the temperament of alien races toward other races. Each byte is a value between 00 and 05, inclusive, and a higher value indicates a friendlier relationship.</p>
<h3 id="labor-robot-heap-labor_heap">Labor Robot Heap (labor_heap)</h3>
<ul>
<li>Total size: 280 (118h) bytes</li>
<li>Record size: 14 (0Eh) bytes</li>
<li>Record count: 20 (14h)</li>
</ul>
<p>Tracks the labor bots that are currently deployed to planets.</p>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>Boolean flag indicating whether this slot is used</td>
</tr>
<tr>
<td>01</td>
<td>Labor bot type (object ID)</td>
</tr>
<tr>
<td>02</td>
<td>Labor bot enhancement (object ID)</td>
</tr>
<tr>
<td>03</td>
<td>Object ID of cargo</td>
</tr>
<tr>
<td>04</td>
<td>Quantity of cargo</td>
</tr>
<tr>
<td>05</td>
<td>Percentage of cargo capacity filled</td>
</tr>
<tr>
<td>06-07</td>
<td>Rate of operation?</td>
</tr>
<tr>
<td>08</td>
<td>Place Table ID of location</td>
</tr>
</tbody>
</table>
<h3 id="setup-table-setup_tab">Setup Table (setup_tab)</h3>
<ul>
<li>Total size: 700 (2BCh) bytes</li>
<li>Record size: 14 (0Eh) bytes</li>
<li>Record count: 50 (32h)</li>
</ul>
<table>
<thead>
<tr>
<th>Byte offset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-01</td>
<td>Place ID?</td>
</tr>
<tr>
<td>02</td>
<td>Ship ID?</td>
</tr>
<tr>
<td>08</td>
<td>Mission ID?</td>
</tr>
</tbody>
</table>
<h2 id="demo-file">Demo file</h2>
<p>The main executable appears to contain code that supports recording and playback of a demo file. The file, named SPACE.DMO, would have a maximum of 1000 (3E8h) records that are each 12 bytes long.</p>
<table>
<thead>
<tr>
<th>Byte ofset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>04</td>
<td>Record type indicator</td>
</tr>
<tr>
<td>06-07</td>
<td>Mouse cursor column position</td>
</tr>
<tr>
<td>08-09</td>
<td>Mouse cursor row position</td>
</tr>
</tbody>
</table>
              
            </div>
          </div>
          <footer>
  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
